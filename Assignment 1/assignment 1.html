<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
   <title>Network Programming (CSE 533) | Assignment 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </title>
   <link REL="stylesheet" HREF="cse533.css">
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>
<body>

<table cellpadding="10">
<tr><td valign="top" align="left" class="title-white"><br>Network Programming<br><br></td>
<td valign="bottom" align="right" class="title-mov"><br>Assignment 1</td></tr>
</table>

<p class="caution"><em>Last updated September 15.</em></p>
<p><big>Due Friday, October 3.</big></p>

<p><big>You are to work on this assignment individually</big>, not in groups.</p>
<!--<p>As I get feedback from students and realize that parts of this write-up need to be extended, corrected, and/or further clarified, I shall update the contents and the <em><font color="#FF00FF">Last Updated</font></em> date. Updated / modified parts will be in <b><font color="#3333FF">bold blue</font></b> for easy identification. Please check this web page periodically to make sure you have the latest version.</p>-->

<p><hr>

<p>The aim of this assignment is to have you do <em>TCP</em> socket client / server programming using I/O multiplexing, child processes and threads. It also aims at getting you to familiarize yourselves with the <em>inetd</em> superserver daemon, the &#8216;<em>exec</em>&#8217; family of functions, various socket error scenarios, some socket options, and some basic domain name / <em>IP</em> address conversion functions. Apart from the material in Chapters 1 to 6 covered in class, you will also need to refer to the following :</p>

<ul>
<li>
the <em>exec</em> family of functions (Section 4.7 of Chapter 4)<br><BR></li>
<li>
using <a target="_blank" href="pipes.html">pipes</a> for interprocess communication (IPC) in <em>Unix</em><br><br></li>
<li>
error scenarios induced by process terminations &amp host crashes (Sections 5.11 to 5.16, Chapter 5)<br><BR></li>
<li>
<em>setsockopt</em> function &amp <em>SO_REUSEADDR</em> socket option (Section 7.2 & <em>pp</em>.210-213, Chapter 7)<br><BR></li>
<li>
<em>gethostbyname</em> &amp; <em>gethostbyaddr </em>functions (Sections 11.3 &amp; 11.4, Chapter 11)<br><BR></li>
<li>
the basic structure of <em>inetd</em> (Section 13.5, Chapter 13)<br><BR></li>
<li>
programming with threads (Sections 26.1 to 26.5, Chapter 26)</li>
</ul>

<h2>Overview</h2>

<p>I shall present an overview of this assignment and discuss some of the specification details given below in class on Wednesday, September 17 &amp; Monday, September 22.</p>

<h2>Client</h2>
<p>The client is evoked with a command line argument giving either the server <em>IP</em> address in dotted decimal notation, or the server domain name. The client has to be able to handle either mode and figure out which of the two is being passed to it. If it is given the <em>IP</em> address, it calls the <em>gethostbyaddr</em> function to get the domain name, which it then prints out to the user in the form of an appropriate message (<em>e.g.</em>, &#8216;The server host is compserv1.cs.stonybrook.edu&#8217;). The function <em>gethostbyname</em>, on the other hand, returns the <em>IP</em> address that corresponds to a given domain name.<!-- Click on the url for a list of the <a a target="_blank" href = "hosts.html">cs hosts</a> you can use.--></p>
<p>The client then enters an infinite loop in which it queries the user which service is being requested. There are two options : <b><em>echo</em></b> and <b><em>time</em></b> (note that <em>time</em> is a slightly modified version of the <em>daytime</em> service &ndash; see below). The client then forks off a child. After the child is forked off, the parent process enters a second loop in which it continually reads and prints out status messages received from the child via a half-duplex pipe (see below). The parent exits the second loop when the child closes the pipe (how does the parent detect this?), and/or the SIGCHLD signal is generated when the child terminates. The parent then repeats the outer loop, querying the user again for the (next) service s/he desires. This cycle continues till the user responds to a query with <b><em>quit</em></b> rather than <b><em>echo</em></b> or <b><em>time</em></b>.</p>
<p>The child process is the one which handles the actual service for the user. It <em>exec</em>s (see Section 4.7, Chapter 4) an <b><em>xterm</em></b> to generate a separate window through which all interactions with server and  user take place. For example, the following <em>exec</em> function call evokes an <em>xterm</em>, and gets the <em>xterm</em> to execute <em>echocli</em>, located in the current directory, passing the string 127.0.0.1 (assumed to be the <em>IP</em> address of the server) as the command line argument <em>argv</em>[1] to <em>echocli</em> (click on the url for further details) :</p><p class="center">
 <a target="_blank" href="exec.html">execlp("xterm", "xterm", "-e", "./echocli", "127.0.0.1", (char *) 0)</a></p>
<p>
<em>xterm</em> executes one of two client programs (<em>echocli</em> or <em>timecli</em>, say) depending on the service requested. A client program establishes a <em>TCP</em> connection to the server at the &#8216;well-known port&#8217; for the service (in reality, this port will, of course, be some ephemeral port of your choosing, the value of which is known to both server and client code). All interaction with the user, on the one hand, and with the server, on the other, takes place through the child&#8217;s <em>xterm</em> window, not the parent&#8217;s window. On the other hand, the child will use a half-duplex pipe to relay status information to the parent which the parent prints out in its window (see below).To terminate the <em>echo</em> client, the user can type in ^D (CTRL D, the EOF character). To terminate the <em>time</em> client, the only option is for the user to type in ^C (CTRL C). (This can also be used as an alternative means of terminating the <em>echo</em> client.) Note that using ^C in the context of the <em>time</em> service will give the server process the impression that the client process has &#8216;crashed&#8217;. It is your responsibility to ensure that the server process handles this correctly and closes cleanly. I shall address this further when discussing the server process.</p>
<p>It is also part of your responsibility in this assignment to ensure that the client code is robust with respect to the server process crashing (see Sections 5.12 &amp; 5.13, Chapter 5). Amongst other implications, this means that it would probably be a good idea for you to implement your <em>echo</em> client code along the lines of either : Figure 6.9, <em>p</em>.168 (or even Figure 6.13, <em>p</em>.174) which uses I/O multiplexing with the <em>select</em> function; or of Figure 26.2, <em>p.</em>680, which uses threads; rather than along the lines of Figure 5.5, <em>p</em>.125.</p>
<p>When the child terminates, either normally or abnormally, its xterm window disappears instantaneously. Consequently, any status information that the child might want to communicate to the user should not be printed out on the child&#8217;s <em>xterm</em> window, since the user will not have time to see the final such message before the window disappears. Instead, as the parent forks off the child at the beginning, a half-duplex pipe should be established from child to parent. The child uses the pipe to send status reports to the parent, which the parent prints out in its window. I leave it up to you to decide what status information exactly should be relayed to the parent but, at a minimum, the parent should certainly be notified, in as precise terms as possible, of any abnormal termination conditions of the service provided by the child.</p>   
<p>In general, you should try to make your code as robust as possible with respect to handling errors, including confused behaviour by the user (<em>e.g</em>., passing an invalid command line argument; responding to a query incorrectly; trying to interact with the service through the parent process window, not the child process <em>xterm</em>; <em>etc</em>.). Amongst other things, you have to worry about <em>EINTR</em> errors occurring during slow system calls (such as the parent reading from the pipe, or, possibly, printing to <em>stdout</em>, for example) due to a <em>SIGCHLD</em> signal. What about other kinds of errors? Which ones can occur? How should you handle them?</p>

<h2>Server</h2>
<p>The server has to be able to handle multiple clients <b>using threads</b> (specifically, <b>detached</b> threads), <b>not</b> child processes (see Sections 26.1 to 26.4, Chapter 26). Furthermore, it has to be able to handle multiple types of service; in our case, two : <em>echo</em> and <em>time</em>. <em>echo</em> is just the standard echo service we have seen in class. <em>time</em> is a slightly modified version of the <em>daytime</em> service (see Figure 1.9, <em>p</em>.14) : instead of sending the client the &#8216;daytime&#8217; just once and closing, the service sits in an infinite loop, sending the &#8216;daytime&#8217;, sleeping for 5 seconds, and repeating, <em>ad infinitum</em>.</p>
<p>The server is <b>loosely</b> based on the way the <em>inetd</em> daemon works : see Figure 13.7, <em>p</em>.374. However, note that the differences between <em>inetd</em> and our server are probably more significant than the similarities: <em>inetd</em> forks off children, whereas our server uses threads; <em>inetd</em> child processes issue <em>exec</em> commands, which our server threads do not; <em>etc</em>. So you should treat Figure 13.7 (and Section 13.5, Chapter 13, generally) as a source of ideas, not as a set of specifications which you must slavishly adhere to and copy. Note, by the way, that there are some similarities between our <b>client</b> and <em>inetd</em> (primarily, forking off children which issue <em>exec</em>s), which could be a useful source of ideas.</p>
<p>The server creates a listening socket for each type of service that it handles, bound to the &#8216;well-known port&#8217; for that service. It then uses <em>select</em> to await clients (Chapter 6; or, if you prefer, <em>poll</em>; note that <em>pselect</em> is not supported in Solaris 2.10). The socket on which a client connects identifies the service the client is seeking. The server <em>accept</em>s the connection and creates a thread which provides the service. The thread detaches itself. Meanwhile, the main thread goes back to the <em>select</em> to await further clients.</p>
<p>A major concern when using threads is to make sure that operations are <b>thread safe</b> (see <em>p</em>.685 and on into Section 26.5). In this respect, Stevens&#8217; <em>readline</em> function (in Stevens&#8217; file <em>unpv13e/lib/readline.c</em>, see Figure 3.18, <em>pp</em>.91-92) poses a particular problem. On <em>p</em>.686, the authors give three options for dealing with this. The third option is too inefficient and should be discarded. You can implement the second option if you wish. Easiest of all would be the first option, since it involves using a thread-safe version of <em>readline</em> (see Figures 26.11 & 26.12) provided in file <em>unpv13e/threads/readline.c</em>. Whatever you do, remember that Stevens&#8217; library, <em>libunp.a</em>, contains the non-thread-safe version of Figure 3.18, and that is the version that will be link-loaded to your code unless you undertake explicit steps to ensure this does not happen (<em>libunp.a</em> also contains the &#8216;wrapper&#8217; function <em>Readline</em>, whose code is also in file <em>unpv13e/lib/readline.c</em>). Remaking your copy of <em>libunp.a</em> with the &#8216;correct&#8217; version of <em>readline</em> is not a viable option because when you hand in your code, it will be compiled and link-loaded with respect to the version of <em>libunp.a</em> in the course account, <em>~cse533/Stevens/unpv13e_solaris2.10</em> (I do not intend to change that version since it risks creating confusion later on in the course). Also, you will probably want to use the original version of <em>readline</em> in the client code anyway. I am providing you with a sample <a target="_blank" href="makefile.html"><em>Makefile</em></a> which picks up the thread-safe version of <em>readline</em> from directory <em>~cse533/Stevens/unpv13e_solaris2.10/threads</em> and uses it when making the executable for the server, but leaves the other executables it makes to link-load the non-thread-safe version from <em>libunp.a</em>.</p>
<p>Again, it is part of your responsibility to make sure that your server code is as robust as possible with respect to errors, and that the server threads terminate cleanly under all circumstances. Recall, first of all, that the client user will often use ^C (CTRL C) in the <em>xterm</em> to terminate the service. This will appear to the server thread as if the client process has crashed. You need to think about the error conditions that will be induced (see Sections 5.11 to 5.13, Chapter 5), and how the <em>echo</em> and <em>time</em> server code is to detect and handle these conditions. For example, the <em>time</em> server will almost certainly experience an <em>EPIPE</em> error (see Section 5.13). How should the associated <em>SIGPIPE</em> signal be handled? Be aware that when we return out of the Stevens&#8217; <em>writen</em> function with -1 (indicating an error) and check <em>errno</em>, <em>errno</em> is sometimes equal to 0, not <em>EPIPE</em> (value 32). This can happen under Solaris 2.10, but I am not sure under precisely what conditions nor why. Nor am I sure if it also happens under other <em>Unix</em> versions, or if it also happens when using <em>write</em> rather than <em>writen</em>. The point is, you cannot depend on <em>errno</em> to find out what has happened to the <em>write</em> or <em>writen</em> functions. My suggestion, therefore, is that the <em>time</em> server should use the <em>select</em> function. On the one hand, <em>select</em>&#8217;s timeout mechanism can be used to make the server sleep for the 5 seconds. On the other hand, <em>select</em> should also monitor the connection socket read event because, when the client <em>xterm</em> is ^C&#8217;ed, a <em>FIN</em> will be sent to the server <em>TCP</em>, which will prime the socket for reading; a read on the socket will then return with value 0 (see Figure 14.3, <em>p</em>. 385 as an example).</p>
<p>But what about errors other than <em>EPIPE</em>? Which ones can occur? How should you handle them? Recall, as well, that if a thread terminates without explicitly closing the connection socket it has been using, the connection socket will remain existent until the server process itself dies (why?). Since the server process is supposed, in principle, to run for ever, you risk ending up with an ever increasing number of unused, &#8216;orphaned&#8217; sockets unless you are careful.</p>
<p>Whenever a server thread detects the termination of its client, it should print out a message giving appropriate details: <i>e.g</i>., &#8220;Client termination: <i>EPIPE</i> error detected&#8221;, &#8220;Client termination: socket read returned with value 0&#8221;, &#8220;Client termination: socket read returned with value -1, errno = . . .&#8221;, and so on.</p>
<p>When debugging your server code, you will probably find that restarting the server very shortly after it was last running will give you trouble when it comes to <em>bind</em> to its &#8216;well-known ports&#8217;. This is because, when the server side initiates connection termination (which is what will happen if the server process crashes; or if you kill it first, before killing the client) <em>TCP</em> keeps the connections open in the <em>TIME_WAIT</em> state for 2<em>MSL</em>s (Sections 2.6 &amp; 2.7, Chapter 2). This could very quickly become a major irritant. I suggest you explore the possibility of using the <em>SO_REUSEADDR</em> socket option (<em>pp</em>.210-213, Chapter 7; note that the <em>SO_REUSEPORT</em> socket option is not supported in Solaris 2.10), which should help keep the stress level down. You will need to use the <em>setsockopt</em> function (Section 7.2) to enable this option. Figure&nbsp;8.24, <em>p</em>.263, shows an instance of server code that sets the <em>SO_REUSEADDR</em> socket option.</p>
<p>Finally, you should be aware of the sort of problem, described in Section 16.6, <em>pp</em>.461-463, that might occur when (blocking) listening sockets are monitored using <em>select</em>. Such sockets should be made nonblocking, which requires use of the <a target="_blank" href="fcntl.html"><em>fcntl</em> </a> &nbsp;function after <em>socket</em> creates the socket, but before <em>listen</em> turns the socket into a listening socket.</p>

<h2>Hand-in</h2>
<p><b><font color="#FF0000">The criterion for a <u>successful</u> assignment is that it execute correctly on the Solaris 10 <em>compserv</em> (<u>not</u> the Linux <em>compute</em>) nodes in the <em>cs.stonybrook.edu</em> domain.</font></b> We shall be testing your code by running clients and server between the following <a target="_blank" href="hosts.html">machines</a>, to which you also have access in order to test your code before handing in.</p>
<p>You should submit your code by logging in to one of the <i>compserv</i>s and using the <a target="_blank" href="handin1.html">electronic hand-in</a> procedure provided. Your submission must absolutely include a <a target="_blank" href="makefile.html"><em>Makefile</em></a> which :</p>
<ul><li>
compiles your code using, where necessary, the Stevens&#8217; environment in the course account, <em>~cse533/Stevens/unpv13e_solaris2.10</em>; and<br><BR></li>
<li>gives the standard names <em>client</em> and <em>server</em> for the client & server executables produced.</li></ul>
<p>Basically, if I am unable, when logged in as <em>cse533</em>, to simply unpack your submission and issue a <em>make</em> which causes your <em>Makefile</em> to successfully compile your code, resulting in executables called <em>client</em> and <em>server</em>, then, so far as I am concerned, your assignment is not even compiling successfully, and will be graded accordingly.</p>

<p></p><hr><p></p>
  <p>
    <a href="http://validator.w3.org/check/referer"><img border="0"
        src="http://www.w3.org/Icons/valid-html401"
        alt="Valid HTML 4.01!" height="31" width="88"></a>
    <a href="http://jigsaw.w3.org/css-validator/check/referer">
       <img style="border:0;width:88px;height:31px"
             src="http://jigsaw.w3.org/css-validator/images/vcss"
             alt="Valid CSS!"></a>
  </p>

</body>
</html>
